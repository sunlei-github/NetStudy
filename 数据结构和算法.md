[Toc]

## 算法

### 复杂度

由于受运行环境的影响，代码的绝对运行时间是无法预估的，但是我们可以通过**代码的基本操作执行次数**来预估代码的执行效率。

### 时间复杂度

**所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比 **

使用大O表示法为：
![image-20210704133957588](D:\学习\vsProject\Study\NetStudy\image-20210704133957588.png)

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码**执行时间随数据规模增长的变化趋势 **，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

**公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。 **

时间复杂度推导原则：

1. 如果运行时长是常数量级的，则用常数1表示。
2. 只保留时间函数中的最高阶项目，其低阶、常量、系数都可以忽略。

几种常见的时间复杂度：

1. O(1) ：O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. O(logn)：循环中进行乘法、除法等操作时，该代码的时间复杂度就是O(logn)。
3. O(n)：一层循环。
4. O(nlogn)：在O(logn)的基础上又进行了了一次循环。
5. O(n2)：n的平方，循环内部又进行了一次循环。

时间复杂度的运行效率，当n的取值足够大的时候：

![image-20210704152656976](D:\学习\vsProject\Study\NetStudy\image-20210704152656976.png)

**当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法**

**时间复杂度类型**

```c
// n表示数组array的长度 
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

 **最好情况时间复杂度**

在最理想的情况下，执行这段代码的时间复杂度。

上面的代码中，如果查找的元素是正好是第一个元素，这个时候就是最好情况时间复杂度，那么当前代码的时间复杂度就是O(1)。

**最坏情况时间复杂度**

在最糟糕的情况下，执行这段代码的时间复杂度。

上面的代码中如果没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂，那么当前代码的时间复杂度也就是O(n)。

**平均情况时间复杂度**

表示在平均情况下，执行这段代码的时间复杂度。

上面的代码中，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

![image-20210704165858739](D:\学习\vsProject\Study\NetStudy\image-20210704165858739.png)

去掉系数后得到的平均复杂度仍然还是O(n)。

### 空间复杂度

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

空间复杂度与时间复杂度类似

几种常见的空间复杂度：

1. O(1)  ：当算法的存储空间是固定的时候。
2. O(n)：线性空间，比如数组等。
3. O(n2)：n的平方，二维数组。

**递归 **

递归是一个比较特殊的场景，虽然代码中并没有显式的申明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈“，”方法调用栈"包含进栈和出栈两个行为，当一个新的方法进栈时，执行入栈操作，把调用的方法和参数信息压入栈中，当方法返回时，执行出栈操作，把调用方法和参数信息从栈中弹出。

**执行递归的操作所需要的内存空间和递归深度成正比，纯粹的递归的操作也是线性的，所以他的空间复杂度也是O(n)**

### 取舍

在绝大数的情况下，时间复杂度更加重要，我们宁可多分配一些内存控件，也要提升程序的运行速度。

## 数据结构

### 线性结构

##### 物理结构

在内存中存放的结构。

###### 数组

![1618741690608](D:\学习\vsProject\Study\NetStudy\1618741690608.png)

**数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 **

黑色代表内存已被使用。

**查找**

查找某个元素。

遍历数组最后会找到或者找不到对应的元素。

**插入**

插入元素到索引是i的位置。

![image-20210511195632901](D:\学习\vsProject\Study\NetStudy\image-20210511195632901.png)

需要将索引是i+1之后的元素都向后移动一位，空出索引是i的位置，然后插入对应的元素。

**删除**

![image-20210511205946223](D:\学习\vsProject\Study\NetStudy\image-20210511205946223.png)

删除所以是i的元素，需要将i+1之后的元素向前移动一位。

存储的特点：

1. 存储的位置是连续的，既不能打乱元素的存储顺序，也不能跳过某个存储单元存储。所以支持下标访问，物理逻辑存储和内存存储都是连续的。
2. 创建时就限定了数组的长度，如果数组的内存已被填充满了，但是仍然想要插入元素，则需要扩容，每次扩容都需要将原来的数组的长度进行一倍的增长，而且如果现在的存储位置不能放下扩容后的数组，则会分配到合适的存储位置，然后将之前的数组拷贝到新的存储位置上。
3. 删除，增加操作时，如果不是尾部的操作，则都会影响到操作元素之后的元素，之后的元素的内容都需要向后或者向前移动一位，如果是更新元素则只需要根据索引读取然后进行替换数组即可，所以数组比较适合读操作而不适合写操作。
4. 支持随机访问，因为内存连续，且类型相同。
5. **如果一个集合不能转换成数组那么说明它的内存不连续**
6. 根据下标访问的时间复杂度是O(1),插入删除的平均时间复杂度是O(n);

**为什么数组从0开始编号**

因为数组的对应的下标，其实应该是相对于数组首个数据的偏移量(offset)，对于第一个元素的偏移量是0。

###### 链表

单向链表

![1618742986760](D:\学习\vsProject\Study\NetStudy\1618742986760.png)

双向链表

![1618743165025](D:\学习\vsProject\Study\NetStudy\1618743165025.png)

**计算链表长度**

需要从链表头遍历到链表尾去获取到链表的长度，链表最后一个的指针域是null。

**查找**

需要从链表头遍历到链表尾去查找对应的元素。

**插入**

![image-20210511211553637](D:\学习\vsProject\Study\NetStudy\image-20210511211553637.png)

1. 构造一个链表项，同时申请内存。
2. 将p的指针域赋值给s的指针域，在将p的指针域指向s的内存。
3. 如果是开头插入和结尾插入其实仍然是改变指针域。

**删除**

![image-20210511212245281](D:\学习\vsProject\Study\NetStudy\image-20210511212245281.png)

1. 将要删除链表项的指针域的赋值给p的指针域，将删除链表项的指针域设置为null。
2. 释放已经删除的指针域的内存。

存储的特点：

1. 存储的位置可以是连续的也可以是不连续的。单向链表每个存储单元中不仅存储了对应的内容，而且里面还存储了下一个存储内容的位置，最后一个存储内容的位置是null。双向链表每个存储单元不仅存储了对应的内容和下一个存储内容的位置，而且还存储了上一个存储单元的位置。链表就是根据每个存储单元里面的存储的位置去查找它的上一个或者下一个存储单元。
2. 链表的长度是动态的，只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要向数组那样考虑扩容。
3. 删除元素时，只需要更新删除元素前一个的next的指针等于删除元素的next指针即可，删除元素的那片内存则会由GC去释放(对于.Net Java等)，如果是双向链表则还需要更新prenext指针。对于增加操作也是对next和prenext指针的更新，不会影响到要修改的元素之后的其他元素，所以这样就间接提高了写的效率，但是因为是根据位置读取所以链表读的效率比较低，只需要修改链即可，不需要修改元素。
4. 单向链表查找“值等于某个给定值”的平均时间复杂度是O(n)，查找“给定指针指向的结点”的时间复杂度是O(1)，增加、删除给定指针指向的结点的平均时间复杂度是O(n),因为他们大概率情况下需要遍历链表找到他们的上一个元素，修改他们前一个元素的next（后继指针）。
5. 双向链表查找“值等于某个给定值”的平均时间复杂度是O(n)，查找“给定指针指向的结点”的时间复杂度是O(1)，增加、删除给定指针指向的结点的平均时间复杂度是O(1)，因为可以根据要修改的元素的prenext找到他的上一个元素然后修改对应的指针位置。

**循环链表**

![image-20210706210623450](D:\学习\vsProject\Study\NetStudy\image-20210706210623450.png)

它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。

**循环链表是一种特殊的单链表**

##### 逻辑结构

###### 栈（Stack）

存储的数据先进后出。

**如果不是动态扩容的栈，那么入栈和出栈的时间复杂度都是O(1)**

**出栈的速度很快，速度大约是List移除元素的五倍左右**

**栈一般是2M，堆一般是4G**

> 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。
> 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。
> 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
> 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。
> 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
> 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。

###### 队列（Queue）

存储的数据先进先出。

**如果不是动态扩容的栈，那么入队和出队的时间复杂度都是O(1)**

**环形队列**

![image-20210707201820423](D:\学习\vsProject\Study\NetStudy\image-20210707201820423.png)

当head=tail说明队列是空的，如果当队列是满的，那么tail所在的位置是不会存储数据的，tail的前一格数据就是队尾数据 ，判断队满的公式**(tail+1)%n=head**

**阻塞队列**

其实就是在队列基础上增加了阻塞操作。当队列为空时，从队列中取数据会被阻塞，直到队列中存入数据，如果队列是满的，向队列中插入数据会被阻塞，直到有数据出队。

**并发队列**

是指一个线程安全的队列，保证多线程操作同一个队列的安全性。

#### 散列表(哈希表)

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。 **

散列表使用散列函数得到对应的散列值，而散列表是根据散列值去存储数据。

散列函数的特点：

1. 散列函数计算得到的散列值是一个非负整数；
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。 但是在真实情况下不同的key得到的散列值可能是一样的，也就是常说的Hash冲突。

**散列冲突(Hash冲突)**

通常解决Hash冲突的方法有多种：

开放寻址法：

![image-20210718161730804](D:\学习\vsProject\Study\NetStudy\image-20210718161730804.png)

当两个不同的key得到的Hash值是一样的时候，但是这个Hash值对应的位置已经存在数据，那么我们就从这个位置向前或者向后查找有没有空余的位置可以存放数据，但是这个方法有个问题就是当我们删除元素的时候不能将这个位置的元素设置为null，否则会导致以这个为参照物的Hash冲突的数据查找失败，所以我们只能将这里要删除的数据标记为deleted。

**适合数据量小的时候使用，因为要预先申请固定内存。**

二次探测：

与开放寻址法类似，开放寻址是每次只向前或者向后探测一个位置，但是二次探测的步长是探测长度的平方，hash(key)+0，hash(key)+1(平方)，hash(key)+2(平方)……

双重散列:
含有多个Hash函数，如果第一个Hash函数得到的Hash值冲突了，那么使用第二个Hash函数计算，以此往下推，知道有一个Hash函数得到的到Hash值不再冲突。

链表法：

![image-20210718161706403](D:\学习\vsProject\Study\NetStudy\image-20210718161706403.png)

当Hash冲突的时候，我们在这个Hash冲突的值后面加上一条链表，用来存放Hash冲突的值。

**适合存放大批量的数据，因为链表的动态延展性**

**散列表的动态扩容 **

需要将旧的散列表的里面的所有的数据取出重新计算散列值，然后再重新摆放到新的散列表中。

**Hash**

**Net中的字典(使用的是链表法)**

![image-20210625210843972](D:\学习\vsProject\Study\NetStudy\image-20210625210843972.png)

![image-20210625211006509](D:\学习\vsProject\Study\NetStudy\image-20210625211006509.png)

**Net中字典的数据结构就类似与在一个数组中,每个元素里面又是一个数组，Hash桶的出现也一定程度上避免了Hash的碰撞**

#### 跳表

跳表是一种二分查找和链表的结合，二分查找的效率很高，但是因为链表不支持下标随机访问，所以将链表改造后就变为了跳表，使的链表查找的时间复杂度从O(n)变为了O(logn)。需要注意的是链表里面的数据也必须是有序的，从小到大或者是从大到小的，否则索引链便失去了意义。

**Redis 中的有序集合（Sorted Set）就是用跳表来实现的。 **

跳表的演变如图：

![image-20210715212759008](D:\学习\vsProject\Study\NetStudy\image-20210715212759008.png)

![image-20210715212810015](D:\学习\vsProject\Study\NetStudy\image-20210715212810015.png)

![image-20210715213825676](D:\学习\vsProject\Study\NetStudy\image-20210715213825676.png)

在原始链表的基础上添加索引链，索引链里面保存了下一级的指针，查找数据的时候，从最上级的索引链逐层往下查找，直到在原始链表中查找到对应的数据。

跳表虽然弥补了链表查询效率低下的问题，但是跳表需要保存索引链，所以需要额外的内存空间，相当于使用空间换取时间的方式来提高了链表的查询效率。

当跳表增加，删除，更新数据的时候，都需要去维护每一层的索引链，否则跳表的可能会退化为单链表，使得查找效率大大较低。

### 非线性结构

#### 树

**树的表示方法 **

**双亲表示法(父节点表示法)**

取一块连续的内存空间，在存储每个结点的同时，各自都附加一个记录其父结点位置的变量。

在树结构中，除了树根外，每个结点都只有一个父结点（又叫“双亲结点”）,又叫做父节点表示法。

经常在数据库中使用这种表达方式。

![image-20210630201158398](D:\学习\vsProject\Study\NetStudy\image-20210630201158398.png)

**孩子链表示法**

将树中的每个结点的孩子结点排列成一个线性表，用链表存储起来。对于含有 n 个结点的树来说，就会有 n 个单链表，将 n 个单链表的头指针存储在一个线性表中，这样的表示方法就是孩子表示法。

![image-20210630201550936](D:\学习\vsProject\Study\NetStudy\image-20210630201550936.png)

生成的树

![image-20210630201630152](D:\学习\vsProject\Study\NetStudy\image-20210630201630152.png)

##### 二叉树

特点

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

树的高度、深度、层:

![image-20210719205254213](D:\学习\vsProject\Study\NetStudy\image-20210719205254213.png)

![image-20210719205305947](D:\学习\vsProject\Study\NetStudy\image-20210719205305947.png)

二叉树的遍历：

前序遍历：

![image-20210719204727311](D:\学习\vsProject\Study\NetStudy\image-20210719204727311.png)

前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历：

![image-20210719204841621](D:\学习\vsProject\Study\NetStudy\image-20210719204841621.png)

中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。**如果是二叉查找树，那么打印出来的数据是有序的**。

后序遍历：

![image-20210719205034250](D:\学习\vsProject\Study\NetStudy\image-20210719205034250.png)

后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

##### 满二叉树

国内的满二叉树是:除叶子节点外,所有的节点都是有两个子节点,而且这个叶子节点指的是”**真正的最后一层**”

也就是总结点数是2^N-1

![image-20210625212940872](D:\学习\vsProject\Study\NetStudy\image-20210625212940872.png)

国外是如果一棵树,他的节点要么是叶子节点,要么他有两个子节点.只要这样就是满二叉树

![image-20210625212948978](D:\学习\vsProject\Study\NetStudy\image-20210625212948978.png)

##### 完全二叉树

![image-20210719204335760](D:\学习\vsProject\Study\NetStudy\image-20210719204335760.png)

叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树

##### 二叉查找树

二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值 。**

二叉查找树最坏的时间复杂度是O(n)，也就是他退化为链表的时候：

![image-20210719205702303](D:\学习\vsProject\Study\NetStudy\image-20210719205702303.png)

当他是一个平衡二叉树的时候，它的平均时间复杂度就是O(logn)

##### 线段树

[参考文章](https://zhuanlan.zhihu.com/p/106118909)

**线段树是一棵**平衡二叉树**。母结点代表整个区间的和，越往下区间越小。注意，线段树的每个**节点**都对应一条**线段（区间）**，但并不保证所有的线段（区间）都是线段树的节点，这两者应当区分开。**

它的大致思想是：将一段大区间平均地划分成 2 个小区间，每一个小区间都再平均分成 2 个更小区间……以此类推（这样这个区间仅包含一个节点的信息，无法被划分）。通过对这些区间进行修改、查询，来实现对大区间的修改、查询。
**但是，可以用线段树维护的问题必须满足 区间加法 ，否则是不可能将大问题划分成子问题来解决的**

线段树主要是把一段大区间 平均地划分 成两段小区间进行维护，再用小区间的值来更新大区间。这样既能保证正确性，又能使时间保持在 log ⁡级别（因为这棵线段树是平衡的）

下图是的线段树是表示了一个[1,2,3,4,5]的数组

![image-20210630202740353](D:\学习\vsProject\Study\NetStudy\image-20210630202740353.png)

##### Trie树(字典树|前缀树)

[参考文章](https://leetcode-cn.com/circle/article/mv8GnX/)

Trie树，即字典树，也有的称为前缀树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

**算法特征**

1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3、每个节点的所有子节点包含的字符都不相同。
4、它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。

**适用范围 **

- 1、单词检索
- 2、统计和排序字符串（但不仅限于字符串）
- 3、字符串前缀

Trie树结构

![image-20210630204753162](D:\学习\vsProject\Study\NetStudy\image-20210630204753162.png)

每个红色节点代表一个字符串的终结，从首个节点到红色节点代表一个字符串。

##### AVL树

[参考文章](https://zhuanlan.zhihu.com/p/56066942)

**AVL树**是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。

**增加和删除元素的操作则可能需要借由一次或多次树旋转（左旋或者右旋），以实现树的重新平衡。**

**二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。 **

**特点**

1. 可以是空树
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

下图是错误的，因为60的左子树不是平衡二叉树

![image-20210630210047589](D:\学习\vsProject\Study\NetStudy\image-20210630210047589.png)

正确的树结构

![image-20210630210357883](D:\学习\vsProject\Study\NetStudy\image-20210630210357883.png)

**左右子树的高度差维持在1**

**平衡因子**：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。

**AVL树失衡调整**

当AVL增加或者删除节点时，就可能会造成树的不平衡。

**最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的**绝对值**超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

**通过最小失衡子树的旋转可以可以减少树的高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 **

最小失衡树，如图：

![image-20210630213045463](D:\学习\vsProject\Study\NetStudy\image-20210630213045463.png)

左旋：

![image-20210630213256422](D:\学习\vsProject\Study\NetStudy\image-20210630213256422.png)

2节点向下移动到C的位置，3节点移动到2的位置，落单的C的节点链接到将落下的2的子节点上。

右旋：

![image-20210630213646590](D:\学习\vsProject\Study\NetStudy\image-20210630213646590.png)

1节点下落到D节点的位置，落单的D节点链接到下落的1的节点的子节点上。

##### 红黑树

[参考文章](https://www.jianshu.com/p/e136ec79235c)

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**
- 每个叶子节点到根的我所有路径上不能有两个连续的红色节点 （**必然结果**）

红黑树图示：

![image-20210630214404158](D:\学习\vsProject\Study\NetStudy\image-20210630214404158.png)

**红黑树在进行增加删除操作时可能会破坏树的平衡，而红黑树维持自平衡需要通过旋转或者是变色（重新标记某些节点的颜色）,维持平衡的意义：保证性能不会退化太严重**

**黑色节点可以包含一个红色节点也可以包含一个黑色节点**

![image-20210630215427021](D:\学习\vsProject\Study\NetStudy\image-20210630215427021.png)

红黑的意义：

**通过节点颜色，限制了二叉树的高度。 
操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。**

**红黑树使用红黑二色进行“着色”，目的是利用颜色值作为二叉树的平衡对称性的检查，只要插入的节点“着色”满足红黑二色的规定，最短路径与最长路径不会相差的太远，红黑树的节点分布就能大体上达至均衡。 **

#### 图

无向图：

![image-20210721204540495](D:\学习\vsProject\Study\NetStudy\image-20210721204540495.png)

有向图：

![image-20210721204609592](D:\学习\vsProject\Study\NetStudy\image-20210721204609592.png)

图中的元素叫做顶点，元素和元素之间的关系(连线)叫做边，跟顶点相连的边树叫做度，顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。

带权图：

![image-20210721205353796](D:\学习\vsProject\Study\NetStudy\image-20210721205353796.png)

在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 两个元素的关系紧密程度。

图的存储方式：

**邻接矩阵**

![image-20210721205530164](D:\学习\vsProject\Study\NetStudy\image-20210721205530164.png)

邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。

用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间，因为**对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了 。如果存储的是稀疏图，顶点很多，但是图里面的边很少，那么大部分的空间都会被浪费掉。**

**邻接表**

![image-20210721210050793](D:\学习\vsProject\Study\NetStudy\image-20210721210050793.png)

类似于散列表，每个顶点之后都需要一个链表或者数组链存储他关联的顶点，如果是有向图（双向的）那么还需要一张逆邻接表来存储他自己的被关注关系。

#### NET

##### List

一个可扩容的数组，每次扩容的长度是原数组的**两倍**，并且会对原数组进行拷贝并迁移到一个新的足够长的内存的地方，List也是实现队列的一种方式。

**一般转换成ToArrary的都是通过将原来的数据结构拷贝到一个连续的内存中，而且一个集合如果是允许使用下标访问的那么说明它存储的内存是连续的**

##### 递归如何避免堆栈溢出问题

**递归存在递进和回归两个阶段，递进的阶段会将运行产生的变量和函数调用的顺序保存在栈中，如果递归的深度过深，由于栈的空间得不到及时释放。栈便会移除，而回归的阶段则会持续释放内存。**

**避免堆栈溢出办法，将递归变成迭代或者循环。**

##### 循环和迭代的区别

循环时依赖变量的长度的，如果循环时，循环的变量的长度发生变化则会引起异常。

迭代元素的时候不需要依赖长度，它只需要知道自己的下一个元素是否为空即可，如果元素不为空则可以一直迭代下去，Foreach底层就是迭代，但是Foreach迭代数组时其实还是循环。

## 算法

参考项目 **SortAlgorithmConsole**

### 排序算法

### 二分查找

**二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0 **

二分查找的时间复杂度是O(logn)，二分查找是十分高效的，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次，因为n 等于 2 的 32 次方，这种查找算法有时比O(n)的算法更加高效，因为O(n)的n可能是一个很大的数值，比如42亿。

二分查找应用场景的局限性：

1. 二分查找依赖的是顺序表结构，简单点说就是数组，因为他是通过每次缩短数组的偏移量来定位数据。
2. 二分查找针对的是有序数据
3. 数据量太大也不适合二分查找，因为存储数组这种数据往往需要很大的连续的内存空间。

### Hash算法

散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。旧译哈希（误以为是人名而采用了音译）。它也常用作一种信息安全的实现方法，由一串数据中经过散列算法（Hashing algorithms）计算出来的数据指纹（data fingerprint），经常用来识别文件与数据是否有被窜改，以保证文件与数据确实是由原创者所提供。

![image-20210625212754058](D:\学习\vsProject\Study\NetStudy\image-20210625212754058.png)

**将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。 **

哈希算法的特点：

1. 从哈希值不能反向推导出原始数据，所以哈希算法也叫单向哈希算法,暴力破解除外。
2. 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；
3. 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；
4. 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

用处：

1. 安全加密：数据库的密码保存使用md5等方式，md5是128为的2进制串，所以当对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情，**一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。 **

2. 唯一表示性：比如用作数据库主键。

3. 数据效验：电驴这样的 BT 下载软件，BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块，然后再组装成一个完整的电影文件，为了确保下载的数据是完整的，需要将下载好的文件进行Hash求值然后和种子文件中的Hash值作比较。

>[原文地址](https://zhuanlan.zhihu.com/p/135358997)
>
>对称加密:
>
>加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。
>
>![image-20210718185145098](D:\学习\vsProject\Study\NetStudy\image-20210718185145098.png)
>
>![image-20210718185129144](D:\学习\vsProject\Study\NetStudy\image-20210718185129144.png)
>
>非对称加密:
>
>非对称加密中是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。
>
>![image-20210718185159273](D:\学习\vsProject\Study\NetStudy\image-20210718185159273.png)
>
>![image-20210718185113349](D:\学习\vsProject\Study\NetStudy\image-20210718185113349.png)
