[Toc]

---

### 单一职责原则

就一个类而言，应该仅有一个引起他变化的原因。

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他的职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

软件设计真正要做的许多内容，就是发现职责并把这些职责相互分离，如果你能想到多于一个的动机去改变一个类，那么这个类就有多于一个的职责。

### 开放封闭原则

软件实体（类，模块，函数等）应该是对扩展开放，对修改关闭。

无论模块是多么的封闭，都会存在一些无法与之封闭的变化，设计人员必须对于他的设计模块应对那种变化封闭作出选择，将最有可能发生变化的种类，就行构建抽象隔离。

开发人员应该对频繁的部分变化进行抽象抽离，但是对于应用程序的每个部分都刻意的进行抽象同样不是一个好的主意，拒绝不成熟的抽象和抽象本身一样重要。

### 依赖倒置原则

高层模块不应该依赖底层模块（业务层高层 数据层低层），两者都应该依赖抽象。

抽象不应该依赖细节，细节应该依赖抽象。

程序中所有的依赖关系都应该是终止与抽象类或者接口。

### 里氏替换原则

一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且察觉不出父类对象和子类对象的区别。也就是说在软件里面，任何父类出现的地方都可以换成它的子类，程序的行为没有发生变化。

只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能在父类的基础上增加新的行为。

### 迪米特法则

 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性 。

过度的使用迪米特法则只会让程序通讯变得更加复杂。

### 接口隔离原则

客户端不应该依赖它不需要的接口。
类间的依赖关系应该建立在最小的接口上。 

 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用 。

### 设计模式总结

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

创建型设计模式更倾向于对象的创建。

结构性设计模式更倾向于使用组合继承等方式去维护类与类之间的关系，使各个类之间都趋于稳定更好扩展。

行为性设计模式更倾向于将具有相同的父类或者接口的类使用一个上下文的类，将这些类进行连接，这些类共享上下文的类的一些状态，然后根据不同的状态去改变对应的行为。

### 设计模式比较

简单工厂默哀是和策略模式：两者实现的方式类似 都是通过上端去指定不同的类型，去创建不同的对象或者是去实现不同的行为。

工厂方法模式与简单工厂模式：简单工厂相对客户端屏蔽了更多的细节，但是对象的创建都集中到简单在工厂中去，如果需要添加新的对象，那么必须修改内部得工厂方法，这就违背了开闭原则，不好扩展，但是工厂方法模式完全遵循了开闭原则，但是对于上端来说上端不仅需要知道自己需要的对象还需要知道实现对象的工厂，也就是说对于上端来说是增加了复杂性。

模板方法模式：主要使用继承的方式在父类中去定义个规范，将某些实现延迟到子类，以便实现不同的功能或者实现不同的业务。

**装饰器模式**：被装饰的对象和装饰器都是有一个共同的父类或者接口，主要是使用里氏替换原则来达到对一个类进行深层次的组合使用。

原型模式：主要是使用深复制或者浅复制来达到对象的创建，在特定的场景下可以提高性。

外观（门面）模式：将子系统进行统一包装处理，然后对外提供方便外部调用子系统的接口，减少耦合，方便维护和扩展，类似于提供一个统一的注册中心，外部调用时直接调用注册中心的服务而不是直接去找对应的服务。

建造者模式：适用于建造比较复杂的对象时，建造者可以将建造该对象的详细信息隐藏的内部中去，是上端依赖变少，而且可以在建造者内部去控制详细的实现步骤来达到不同的效果，比如常用的IOC容器就类似于一个建造者模式。

**观察者模式**：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个对象主题，当这个主题对应的状态发生变化时，会通知所有观察者对象，使他们能够自己更新自己。实现方式通常有接口，或者委托等。

状态模式：将if else switch 等特别臃肿的分支判断转移到每个状态类里面，之后再有新的状态只需要去扩展对应的状态类即可。