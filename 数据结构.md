[Toc]

---

## 线性结构

### 物理结构

在内存中存放的结构。

#### 数组

![1618741690608](D:\学习\vsProject\Study\NetStudy\1618741690608.png)

黑色代表内存已被使用。

**查找**

查找某个元素。

遍历数组最后会找到或者找不到对应的元素。

**插入**

插入元素到索引是i的位置。

![image-20210511195632901](D:\学习\vsProject\Study\NetStudy\image-20210511195632901.png)

需要将索引是i+1之后的元素都向后移动一位，空出索引是i的位置，然后插入对应的元素。

**删除**

![image-20210511205946223](D:\学习\vsProject\Study\NetStudy\image-20210511205946223.png)

删除所以是i的元素，需要将i+1之后的元素向前移动一位。

存储的特点：

1. 存储的位置是连续的，既不能打乱元素的存储顺序，也不能跳过某个存储单元存储。所以支持下标访问，物理逻辑存储和内存存储都是连续的。
2. 创建时就限定了数组的长度，如果数组的内存已被填充满了，但是仍然想要插入元素，则需要扩容，每次扩容都需要将原来的数组的长度进行一倍的增长，而且如果现在的存储位置不能放下扩容后的数组，则会分配到合适的存储位置，然后将之前的数组拷贝到新的存储位置上。
3. 删除，增加操作时，如果不是尾部的操作，则都会影响到操作元素之后的元素，之后的元素的内容都需要向后或者向前移动一位，如果是更新元素则只需要根据索引读取然后进行替换数组即可，所以数组比较适合读操作而不适合写操作。
4. **如果一个集合不能转换成数组那么说明它的内存不连续**

#### 链表

单向链表

![1618742986760](D:\学习\vsProject\Study\NetStudy\1618742986760.png)

双向链表

![1618743165025](D:\学习\vsProject\Study\NetStudy\1618743165025.png)

**计算链表长度**

需要从链表头遍历到链表尾去获取到链表的长度，链表最后一个的指针域是null。

**查找**

需要从链表头遍历到链表尾去查找对应的元素。

**插入**

![image-20210511211553637](D:\学习\vsProject\Study\NetStudy\image-20210511211553637.png)

1. 构造一个链表项，同时申请内存。
2. 将p的指针域赋值给s的指针域，在将p的指针域指向s的内存。
3. 如果是开头插入和结尾插入其实仍然是改变指针域。

**删除**

![image-20210511212245281](D:\学习\vsProject\Study\NetStudy\image-20210511212245281.png)

1. 将要删除链表项的指针域的赋值给p的指针域，将删除链表项的指针域设置为null。
2. 释放已经删除的指针域的内存。

存储的特点：

1. 存储的位置可以是连续的也可以是不连续的。单向链表每个存储单元中不仅存储了对应的内容，而且里面还存储了下一个存储内容的位置，最后一个存储内容的位置是null。双向链表每个存储单元不仅存储了对应的内容和下一个存储内容的位置，而且还存储了上一个存储单元的位置。链表就是根据每个存储单元里面的存储的位置去查找它的上一个或者下一个存储单元。
2. 链表的长度是动态的，只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要向数组那样考虑扩容。
3. 删除元素时，只需要更新删除元素前一个的next的指针等于删除元素的next指针即可，删除元素的那片内存则会由GC去释放(对于.Net Java等)，如果是双向链表则还需要更新prenext指针。对于增加操作也是对next和prenext指针的更新，不会影响到要修改的元素之后的其他元素，所以这样就间接提高了写的效率，但是因为是根据位置读取所以链表读的效率比较低，只需要修改链即可，不需要修改元素。

## 逻辑结构

### 栈（Stack）

存储的数据先进后出。

**出栈的速度很快，速度大约是List移除元素的五倍左右**

**栈一般是2M，堆一般是4G**

### 队列（Queue）

存储的数据先进先出。

**如果一个集合不能转换成数组那么说明它的内存不连续**

### 散列表(哈希表)

散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。旧译哈希（误以为是人名而采用了音译）。它也常用作一种信息安全的实现方法，由一串数据中经过散列算法（Hashing algorithms）计算出来的数据指纹（data fingerprint），经常用来识别文件与数据是否有被窜改，以保证文件与数据确实是由原创者所提供。

他的另外一个名字:散列算法

**散列算法也被用来加密存在数据库中的密码（password）字符串，由于散列算法所计算出来的散列值（Hash Value）具有不可逆（无法逆向演算回原本的数值）的性质，因此可有效的保护密码**

![image-20210625212754058](D:\学习\vsProject\Study\NetStudy\image-20210625212754058.png)

**Hash**

**Net中的字典**

![image-20210625210843972](D:\学习\vsProject\Study\NetStudy\image-20210625210843972.png)

![image-20210625211006509](D:\学习\vsProject\Study\NetStudy\image-20210625211006509.png)

**Net中字典的数据结构就类似与在一个数组中,每个元素里面又是一个数组，Hash桶的出现也一定程度上避免了Hash的碰撞**

## 树

国内的满二叉树是:除叶子节点外,所有的节点都是有两个子节点,而且这个叶子节点指的是”真正的最后一层”

也就是总结点数是2^N-1

![image-20210625212940872](D:\学习\vsProject\Study\NetStudy\image-20210625212940872.png)

国外是如果一棵树,他的节点要么是叶子节点,要么他有两个子节点.只要这样就是满二叉树

![image-20210625212948978](D:\学习\vsProject\Study\NetStudy\image-20210625212948978.png)

## NET

### List

一个可扩容的数组，每次扩容的长度是原数组的**两倍**，并且会对原数组进行拷贝并迁移到一个新的足够长的内存的地方，List也是实现队列的一种方式。

**一般转换成ToArrary的都是通过将原来的数据结构拷贝到一个连续的内存中，而且一个集合如果是允许使用下标访问的那么说明它存储的内存是连续的**

### 递归如何避免堆栈溢出问题

**递归存在递进和回归两个阶段，递进的阶段会将运行产生的变量和函数调用的顺序保存在栈中，如果递归的深度过深，由于栈的空间得不到及时释放。栈便会移除，而回归的阶段则会持续释放内存。**

**避免堆栈溢出办法，将递归变成迭代或者循环。**

### 循环和迭代的区别

循环时依赖变量的长度的，如果循环时，循环的变量的长度发生变化则会引起异常。

迭代元素的时候不需要依赖长度，它只需要知道自己的下一个元素是否为空即可，如果元素不为空则可以一直迭代下去，Foreach底层就是迭代，但是Foreach迭代数组时其实还是循环。

