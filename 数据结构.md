[Toc]

---

## 线性结构

### 物理结构

在内存中存放的结构。

#### 数组

![1618741690608](D:\学习\vsProject\Study\NetStudy\1618741690608.png)

黑色代表内存已被使用。

**查找**

查找某个元素。

遍历数组最后会找到或者找不到对应的元素。

**插入**

插入元素到索引是i的位置。

![image-20210511195632901](D:\学习\vsProject\Study\NetStudy\image-20210511195632901.png)

需要将索引是i+1之后的元素都向后移动一位，空出索引是i的位置，然后插入对应的元素。

**删除**

![image-20210511205946223](D:\学习\vsProject\Study\NetStudy\image-20210511205946223.png)

删除所以是i的元素，需要将i+1之后的元素向前移动一位。

存储的特点：

1. 存储的位置是连续的，既不能打乱元素的存储顺序，也不能跳过某个存储单元存储。所以支持下标访问，物理逻辑存储和内存存储都是连续的。
2. 创建时就限定了数组的长度，如果数组的内存已被填充满了，但是仍然想要插入元素，则需要扩容，每次扩容都需要将原来的数组的长度进行一倍的增长，而且如果现在的存储位置不能放下扩容后的数组，则会分配到合适的存储位置，然后将之前的数组拷贝到新的存储位置上。
3. 删除，增加操作时，如果不是尾部的操作，则都会影响到操作元素之后的元素，之后的元素的内容都需要向后或者向前移动一位，如果是更新元素则只需要根据索引读取然后进行替换数组即可，所以数组比较适合读操作而不适合写操作。

#### 链表

单向链表

![1618742986760](D:\学习\vsProject\Study\NetStudy\1618742986760.png)

双向链表

![1618743165025](D:\学习\vsProject\Study\NetStudy\1618743165025.png)

**计算链表长度**

需要从链表头遍历到链表尾去获取到链表的长度，链表最后一个的指针域是null。

**查找**

需要从链表头遍历到链表尾去查找对应的元素。

**插入**

![image-20210511211553637](D:\学习\vsProject\Study\NetStudy\image-20210511211553637.png)

1. 构造一个链表项，同时申请内存。
2. 将p的指针域赋值给s的指针域，在将p的指针域指向s的内存。
3. 如果是开头插入和结尾插入其实仍然是改变指针域。

**删除**

![image-20210511212245281](D:\学习\vsProject\Study\NetStudy\image-20210511212245281.png)

1. 将要删除链表项的指针域的赋值给p的指针域，将删除链表项的指针域设置为null。
2. 释放已经删除的指针域的内存。

存储的特点：

1. 存储的位置可以是连续的也可以是不连续的。单向链表每个存储单元中不仅存储了对应的内容，而且里面还存储了下一个存储内容的位置，最后一个存储内容的位置是null。双向链表每个存储单元不仅存储了对应的内容和下一个存储内容的位置，而且还存储了上一个存储单元的位置。链表就是根据每个存储单元里面的存储的位置去查找它的上一个或者下一个存储单元。
2. 链表的长度是动态的，只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要向数组那样考虑扩容。
3. 删除元素时，只需要更新删除元素前一个的next的指针等于删除元素的next指针即可，删除元素的那片内存则会由GC去释放(对于.Net Java等)，如果是双向链表则还需要更新prenext指针。对于增加操作也是对next和prenext指针的更新，不会影响到要修改的元素之后的其他元素，所以这样就间接提高了写的效率，但是因为是根据位置读取所以链表读的效率比较低，只需要修改链即可，不需要修改元素。

### 逻辑结构

### 栈

特点：

存储的数据先进后出。

### 队列

存储的数据先进先出。

### 散列表(哈希表)

类似于一个字典项，由key-value组成的一个集合

