[Toc]

## 算法

### 复杂度

由于受运行环境的影响，代码的绝对运行时间是无法预估的，但是我们可以通过**代码的基本操作执行次数**来预估代码的执行效率。

### 时间复杂度

**所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比 **

使用大O表示法为：
![image-20210704133957588](D:\学习\vsProject\Study\NetStudy\image-20210704133957588.png)

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码**执行时间随数据规模增长的变化趋势 **，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

**公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。 **

时间复杂度推导原则：

1. 如果运行时长是常数量级的，则用常数1表示。
2. 只保留时间函数中的最高阶项目，其低阶、常量、系数都可以忽略。

几种常见的时间复杂度：

1. O(1) ：O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。
2. O(logn)：循环中进行乘法、除法等操作时，该代码的时间复杂度就是O(logn)。
3. O(n)：一层循环。
4. O(nlogn)：在O(logn)的基础上又进行了了一次循环。
5. O(n2)：n的平方，循环内部又进行了一次循环。

时间复杂度的运行效率，当n的取值足够大的时候：

![image-20210704152656976](D:\学习\vsProject\Study\NetStudy\image-20210704152656976.png)

**当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法**

**时间复杂度类型**

```c
// n表示数组array的长度 
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

 **最好情况时间复杂度**

在最理想的情况下，执行这段代码的时间复杂度。

上面的代码中，如果查找的元素是正好是第一个元素，这个时候就是最好情况时间复杂度，那么当前代码的时间复杂度就是O(1)。

**最坏情况时间复杂度**

在最糟糕的情况下，执行这段代码的时间复杂度。

上面的代码中如果没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂，那么当前代码的时间复杂度也就是O(n)。

**平均情况时间复杂度**

表示在平均情况下，执行这段代码的时间复杂度。

上面的代码中，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

![image-20210704165858739](D:\学习\vsProject\Study\NetStudy\image-20210704165858739.png)

去掉系数后得到的平均复杂度仍然还是O(n)。

### 空间复杂度

空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

空间复杂度与时间复杂度类似

几种常见的空间复杂度：

1. O(1)  ：当算法的存储空间是固定的时候。
2. O(n)：线性空间，比如数组等。
3. O(n2)：n的平方，二维数组。

**递归 **

递归是一个比较特殊的场景，虽然代码中并没有显式的申明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方法调用栈“，”方法调用栈"包含进栈和出栈两个行为，当一个新的方法进栈时，执行入栈操作，把调用的方法和参数信息压入栈中，当方法返回时，执行出栈操作，把调用方法和参数信息从栈中弹出。

**执行递归的操作所需要的内存空间和递归深度成正比，纯粹的递归的操作也是线性的，所以他的空间复杂度也是O(n)**

### 取舍

在绝大数的情况下，时间复杂度更加重要，我们宁可多分配一些内存控件，也要提升程序的运行速度。

## 数据结构

### 线性结构

#### 物理结构

在内存中存放的结构。

#### 数组

![1618741690608](D:\学习\vsProject\Study\NetStudy\1618741690608.png)

黑色代表内存已被使用。

**查找**

查找某个元素。

遍历数组最后会找到或者找不到对应的元素。

**插入**

插入元素到索引是i的位置。

![image-20210511195632901](D:\学习\vsProject\Study\NetStudy\image-20210511195632901.png)

需要将索引是i+1之后的元素都向后移动一位，空出索引是i的位置，然后插入对应的元素。

**删除**

![image-20210511205946223](D:\学习\vsProject\Study\NetStudy\image-20210511205946223.png)

删除所以是i的元素，需要将i+1之后的元素向前移动一位。

存储的特点：

1. 存储的位置是连续的，既不能打乱元素的存储顺序，也不能跳过某个存储单元存储。所以支持下标访问，物理逻辑存储和内存存储都是连续的。
2. 创建时就限定了数组的长度，如果数组的内存已被填充满了，但是仍然想要插入元素，则需要扩容，每次扩容都需要将原来的数组的长度进行一倍的增长，而且如果现在的存储位置不能放下扩容后的数组，则会分配到合适的存储位置，然后将之前的数组拷贝到新的存储位置上。
3. 删除，增加操作时，如果不是尾部的操作，则都会影响到操作元素之后的元素，之后的元素的内容都需要向后或者向前移动一位，如果是更新元素则只需要根据索引读取然后进行替换数组即可，所以数组比较适合读操作而不适合写操作。
4. **如果一个集合不能转换成数组那么说明它的内存不连续**

#### 链表

单向链表

![1618742986760](D:\学习\vsProject\Study\NetStudy\1618742986760.png)

双向链表

![1618743165025](D:\学习\vsProject\Study\NetStudy\1618743165025.png)

**计算链表长度**

需要从链表头遍历到链表尾去获取到链表的长度，链表最后一个的指针域是null。

**查找**

需要从链表头遍历到链表尾去查找对应的元素。

**插入**

![image-20210511211553637](D:\学习\vsProject\Study\NetStudy\image-20210511211553637.png)

1. 构造一个链表项，同时申请内存。
2. 将p的指针域赋值给s的指针域，在将p的指针域指向s的内存。
3. 如果是开头插入和结尾插入其实仍然是改变指针域。

**删除**

![image-20210511212245281](D:\学习\vsProject\Study\NetStudy\image-20210511212245281.png)

1. 将要删除链表项的指针域的赋值给p的指针域，将删除链表项的指针域设置为null。
2. 释放已经删除的指针域的内存。

存储的特点：

1. 存储的位置可以是连续的也可以是不连续的。单向链表每个存储单元中不仅存储了对应的内容，而且里面还存储了下一个存储内容的位置，最后一个存储内容的位置是null。双向链表每个存储单元不仅存储了对应的内容和下一个存储内容的位置，而且还存储了上一个存储单元的位置。链表就是根据每个存储单元里面的存储的位置去查找它的上一个或者下一个存储单元。
2. 链表的长度是动态的，只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要向数组那样考虑扩容。
3. 删除元素时，只需要更新删除元素前一个的next的指针等于删除元素的next指针即可，删除元素的那片内存则会由GC去释放(对于.Net Java等)，如果是双向链表则还需要更新prenext指针。对于增加操作也是对next和prenext指针的更新，不会影响到要修改的元素之后的其他元素，所以这样就间接提高了写的效率，但是因为是根据位置读取所以链表读的效率比较低，只需要修改链即可，不需要修改元素。

### 逻辑结构

#### 栈（Stack）

存储的数据先进后出。

**出栈的速度很快，速度大约是List移除元素的五倍左右**

**栈一般是2M，堆一般是4G**

#### 队列（Queue）

存储的数据先进先出。

**如果一个集合不能转换成数组那么说明它的内存不连续**

#### 散列表(哈希表)

散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。旧译哈希（误以为是人名而采用了音译）。它也常用作一种信息安全的实现方法，由一串数据中经过散列算法（Hashing algorithms）计算出来的数据指纹（data fingerprint），经常用来识别文件与数据是否有被窜改，以保证文件与数据确实是由原创者所提供。

他的另外一个名字:散列算法

**散列算法也被用来加密存在数据库中的密码（password）字符串，由于散列算法所计算出来的散列值（Hash Value）具有不可逆（无法逆向演算回原本的数值）的性质，因此可有效的保护密码**

![image-20210625212754058](D:\学习\vsProject\Study\NetStudy\image-20210625212754058.png)

**Hash**

**Net中的字典**

![image-20210625210843972](D:\学习\vsProject\Study\NetStudy\image-20210625210843972.png)

![image-20210625211006509](D:\学习\vsProject\Study\NetStudy\image-20210625211006509.png)

**Net中字典的数据结构就类似与在一个数组中,每个元素里面又是一个数组，Hash桶的出现也一定程度上避免了Hash的碰撞**

### 树

#### 树的表示方法

**双亲表示法(父节点表示法)**

取一块连续的内存空间，在存储每个结点的同时，各自都附加一个记录其父结点位置的变量。

在树结构中，除了树根外，每个结点都只有一个父结点（又叫“双亲结点”）,又叫做父节点表示法。

经常在数据库中使用这种表达方式。

![image-20210630201158398](D:\学习\vsProject\Study\NetStudy\image-20210630201158398.png)

**孩子链表示法**

将树中的每个结点的孩子结点排列成一个线性表，用链表存储起来。对于含有 n 个结点的树来说，就会有 n 个单链表，将 n 个单链表的头指针存储在一个线性表中，这样的表示方法就是孩子表示法。

![image-20210630201550936](D:\学习\vsProject\Study\NetStudy\image-20210630201550936.png)

生成的树

![image-20210630201630152](D:\学习\vsProject\Study\NetStudy\image-20210630201630152.png)

#### 二叉树

特点

1. 本身是有序树；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；

#### 满二叉树

国内的满二叉树是:除叶子节点外,所有的节点都是有两个子节点,而且这个叶子节点指的是”**真正的最后一层**”

也就是总结点数是2^N-1

![image-20210625212940872](D:\学习\vsProject\Study\NetStudy\image-20210625212940872.png)

国外是如果一棵树,他的节点要么是叶子节点,要么他有两个子节点.只要这样就是满二叉树

![image-20210625212948978](D:\学习\vsProject\Study\NetStudy\image-20210625212948978.png)

#### 完全二叉树

#### 二叉查找树

####线段树

[参考文章](https://zhuanlan.zhihu.com/p/106118909)

**线段树是一棵**平衡二叉树**。母结点代表整个区间的和，越往下区间越小。注意，线段树的每个**节点**都对应一条**线段（区间）**，但并不保证所有的线段（区间）都是线段树的节点，这两者应当区分开。**

它的大致思想是：将一段大区间平均地划分成 2 个小区间，每一个小区间都再平均分成 2 个更小区间……以此类推（这样这个区间仅包含一个节点的信息，无法被划分）。通过对这些区间进行修改、查询，来实现对大区间的修改、查询。
**但是，可以用线段树维护的问题必须满足 区间加法 ，否则是不可能将大问题划分成子问题来解决的**

线段树主要是把一段大区间 平均地划分 成两段小区间进行维护，再用小区间的值来更新大区间。这样既能保证正确性，又能使时间保持在 log ⁡级别（因为这棵线段树是平衡的）

下图是的线段树是表示了一个[1,2,3,4,5]的数组

![image-20210630202740353](D:\学习\vsProject\Study\NetStudy\image-20210630202740353.png)

#### Trie树(字典树|前缀树)

[参考文章](https://leetcode-cn.com/circle/article/mv8GnX/)

Trie树，即字典树，也有的称为前缀树，是一种树形结构。广泛应用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

**算法特征**

1、根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2、从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3、每个节点的所有子节点包含的字符都不相同。
4、它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。

**适用范围 **

- 1、单词检索
- 2、统计和排序字符串（但不仅限于字符串）
- 3、字符串前缀

Trie树结构

![image-20210630204753162](D:\学习\vsProject\Study\NetStudy\image-20210630204753162.png)

每个红色节点代表一个字符串的终结，从首个节点到红色节点代表一个字符串。

#### AVL树

[参考文章](https://zhuanlan.zhihu.com/p/56066942)

**AVL树**是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。

**增加和删除元素的操作则可能需要借由一次或多次树旋转（左旋或者右旋），以实现树的重新平衡。**

**二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。 **

**特点**

1. 可以是空树
2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

下图是错误的，因为60的左子树不是平衡二叉树

![image-20210630210047589](D:\学习\vsProject\Study\NetStudy\image-20210630210047589.png)

正确的树结构

![image-20210630210357883](D:\学习\vsProject\Study\NetStudy\image-20210630210357883.png)

**左右子树的高度差维持在1**

**平衡因子**：某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。

**AVL树失衡调整**

当AVL增加或者删除节点时，就可能会造成树的不平衡。

**最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的**绝对值**超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。

**通过最小失衡子树的旋转可以可以减少树的高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。 **

最小失衡树，如图：

![image-20210630213045463](D:\学习\vsProject\Study\NetStudy\image-20210630213045463.png)

左旋：

![image-20210630213256422](D:\学习\vsProject\Study\NetStudy\image-20210630213256422.png)

2节点向下移动到C的位置，3节点移动到2的位置，落单的C的节点链接到将落下的2的子节点上。

右旋：

![image-20210630213646590](D:\学习\vsProject\Study\NetStudy\image-20210630213646590.png)

1节点下落到D节点的位置，落单的D节点链接到下落的1的节点的子节点上。

#### 红黑树

[参考文章](https://www.jianshu.com/p/e136ec79235c)

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

- 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
- 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
- **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**
- 每个叶子节点到根的我所有路径上不能有两个连续的红色节点 （**必然结果**）

红黑树图示：

![image-20210630214404158](D:\学习\vsProject\Study\NetStudy\image-20210630214404158.png)

**红黑树在进行增加删除操作时可能会破坏树的平衡，而红黑树维持自平衡需要通过旋转或者是变色（重新标记某些节点的颜色）**

**黑色节点可以包含一个红色节点也可以包含一个黑色节点**

![image-20210630215427021](D:\学习\vsProject\Study\NetStudy\image-20210630215427021.png)





红黑的意义：

**通过节点颜色，限制了二叉树的高度。 
操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。**

**红黑树使用红黑二色进行“着色”，目的是利用颜色值作为二叉树的平衡对称性的检查，只要插入的节点“着色”满足红黑二色的规定，最短路径与最长路径不会相差的太远，红黑树的节点分布就能大体上达至均衡。 **

### NET

#### List

一个可扩容的数组，每次扩容的长度是原数组的**两倍**，并且会对原数组进行拷贝并迁移到一个新的足够长的内存的地方，List也是实现队列的一种方式。

**一般转换成ToArrary的都是通过将原来的数据结构拷贝到一个连续的内存中，而且一个集合如果是允许使用下标访问的那么说明它存储的内存是连续的**

#### 递归如何避免堆栈溢出问题

**递归存在递进和回归两个阶段，递进的阶段会将运行产生的变量和函数调用的顺序保存在栈中，如果递归的深度过深，由于栈的空间得不到及时释放。栈便会移除，而回归的阶段则会持续释放内存。**

**避免堆栈溢出办法，将递归变成迭代或者循环。**

#### 循环和迭代的区别

循环时依赖变量的长度的，如果循环时，循环的变量的长度发生变化则会引起异常。

迭代元素的时候不需要依赖长度，它只需要知道自己的下一个元素是否为空即可，如果元素不为空则可以一直迭代下去，Foreach底层就是迭代，但是Foreach迭代数组时其实还是循环。

