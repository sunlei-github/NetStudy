[Toc]

---

### 架构图

![微服务图示](D:\学习\vsProject\Study\NetStudy\1612533859963.png)

**微服务特点：**

1. 微服务单一职责原则
2. 每个微服务应该有且只有一个服务
3. 一个微服务升级更新，不会影响到其他的微服务 
4. 可以更快的迭代
5. 性能更好，每个微服务可以进行单独的集群以及读写分离

![微服务架构图](D:\学习\vsProject\Study\NetStudy\1612531276256.png)

微服务层：按业务拆分微服务形成微服务层，微服务直接各个相互独立，各个微服务直接可以做集群，提高可用性（高可用），每种微服务对应各自的数据库，每种微服务之间是项目独立互不干扰的。

聚合层：为了适应复杂业务，需要聚合多个微服务，聚合层不是必须的。

工具层：基础层，这里没有业务，只是封装了各种支持应用程序的工具。

网关层：进行权限认证，请求转发等。

UI层：由于网关暴露的数据接口，所以方便程序适配各个客户端。

### 注册中心（Consul）

![注册中心在微服务的位置](D:\学习\vsProject\Study\NetStudy\1612532700867.png)



![服务在Consul中的注册和移除](D:\学习\vsProject\Study\NetStudy\1612533230262.png)

> - 1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port
> - 2、Consul 接收到 Producer 的注册后，每隔10s（默认）会向 Producer 发送一个健康检查的请求，检验Producer是否健康
> - 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address
> - 4、该临时表每隔10s会更新，只包含有通过了健康检查的 Producer

由于微服务是各个独立互不干扰的所以需要通过其他方式去管理零散的微服务，所以当每个微服务启动的时候都需要将对应的应用程序注册到服务中心进行管理，服务中心通过心跳的方式去增加和移除已经启动或者销毁的服务，聚合层或者网关层不能直接调用微服务层，而是需要根据不同的请求去服务中心查找对应的微服务地址进行调用。

### 熔断降级（Polly）

#### 熔断

![1614413774933](D:\学习\vsProject\Study\NetStudy\1614413774933.png)

熔断就是在被调用端出现宕机，和超时两种情况出现的一种策略应对机制，如果微服务连续多次出现宕机或者超时现象，那么可以将出现这种情况的服务进行熔断处理，提高系统的稳定性以及节省性能。

**熔断原理**

![1614414025170](D:\学习\vsProject\Study\NetStudy\1614414025170.png)

聚合微服务请求微服务时，被请求的微服务处于宕机或者超时状态，那么便会返回超时，计算机拒绝等异常，而且下次如果再次请求该微服务时，可能该微服务仍然可能处于不正常的状态，所以为了提高可用性和节省性能，在中间加入熔断器，当一个微服务连续请求失败多次后我们便认为该服务处于不正常状态，熔断器便会记录下请求的地址，下次再次请求该服务的时候，便不会再直接请求该微服务，而是直接抛出一个熔断的异常。

#### 降级

![1614413930060](D:\学习\vsProject\Study\NetStudy\1614413930060.png)

主动对某些服务进行异常返回，选择性放弃可以提高系统的性能，当访问的服务宕机或者超时，可以进行异常降级，也可以请求缓存数据，实现高可用。

**降级原理**

![1614414539571](D:\学习\vsProject\Study\NetStudy\1614414539571.png)

当访问的微服务出现异常（或者是熔断器抛出了异常）那么为了使系统可以正常运行，那么便在此处加入降级，对于请求失败的微服务（或者是选择性使用的微服务），我们可以去缓存中请求数据，或者是返回一系列友好的的异常提示，一般来说熔断和降级是配合使用，从而提高系统的稳定性。

### 网关 （Ocelot）

![1614476276655](D:\学习\vsProject\Study\NetStudy\1614476276655.png)

使用网关的好处：

1. 客户端和微服务进行解耦，客户端不再直接请求固定的微服务
2. 保护微服务，客户端必须通过请求网关，然后网关去转发到对应的微服务
3. 隔离，对于非业务模块比如：验证，授权，不再每个微服务中去单独添加，而是有网关控制
4. 限流，限制客户端请求的数量，避免高并发导致的系统不稳定
5. 聚合服务，让客户端的访问都有一个统一的接口，一定层次上解耦客户端与服务。
6. 进行负载均衡，集群时使用。

**Ocelot原理**

![1614478373278](D:\学习\vsProject\Study\NetStudy\1614478373278.png)

Ocelot 接收到客户端的服务后，以中间件的形式转发和接受响应，再次返回给客户端。

#### Ocelot的主要配置

完整的路由配置

```json
{
    "DownstreamPathTemplate": "/",
    "UpstreamPathTemplate": "/",
    "UpstreamHttpMethod": [
   	 "Get"
    ],
    "AddHeadersToRequest": {},
    "AddClaimsToRequest": {},
    "RouteClaimsRequirement": {},
    "AddQueriesToRequest": {},
    "RequestIdKey": "",
    "FileCacheOptions": {
    "TtlSeconds": 0,
    "Region": ""
    },
    "ReRouteIsCaseSensitive": false,
    "ServiceName": "",
    "DownstreamScheme": "http",
    "DownstreamHostAndPorts": [
    {
    "Host": "localhost",
    "Port": 51876,
    }
    ],
    "QoSOptions": {
    "ExceptionsAllowedBeforeBreaking": 0,
    "DurationOfBreak": 0,
    "TimeoutValue": 0
    },
    "LoadBalancer": "",
    "RateLimitOptions": {
    "ClientWhitelist": [],
    "EnableRateLimiting": false,
    "Period": "",
    "PeriodTimespan": 0,
    "Limit": 0
    },
    "AuthenticationOptions": {
    "AuthenticationProviderKey": "",
    "AllowedScopes": []
    },
    "HttpHandlerOptions": {
    "AllowAutoRedirect": true,
    "UseCookieContainer": true,
    "UseTracing": true
    },
    "UseServiceDiscovery": false
}
```



>- Downstream是下游服务配置
>- UpStream是上游服务配置
>- Aggregates 服务聚合配置
>- ServiceName, LoadBalancer, UseServiceDiscovery 配置服务发现
>- AuthenticationOptions 配置服务认证
>- RouteClaimsRequirement 配置Claims鉴权
>- RateLimitOptions为限流配置
>- FileCacheOptions 缓存配置
>- QosOptions 服务质量与熔断
>- DownstreamHeaderTransform头 信息转发

**路由基本配置**

``` json
{
"DownstreamPathTemplate": "/api/post/{postId}",
"DownstreamScheme": "https",
"DownstreamHostAndPorts": [
{
"Host": "localhost",
"Port": 80,
}
],
"UpstreamPathTemplate": "/post/{postId}",
"UpstreamHttpMethod": [ "Get"]
}
```



>DownstreamPathTemplate：下游路径模板
>
>DownstreamScheme：下游服务http schema
>
>DownstreamHostAndPorts：下游服务的地址，如果使用LoadBalancer的话这里可以填多项
>
>UpstreamPathTemplate: 上游也就是用户输入的请求Url模板
>
>UpstreamHttpMethod: 上游请求http方法，可使用数组

**路由负载均衡的配置**

```json
{
    "DownstreamPathTemplate": "/api/posts/{postId}",
    "DownstreamScheme": "https",
    "DownstreamHostAndPorts": [
            {
                "Host": "10.0.1.10",
                "Port": 5000,
            },
            {
                "Host": "10.0.1.11",
                "Port": 5000,
            }
        ],
    "UpstreamPathTemplate": "/posts/{postId}",
    "LoadBalancerOptions": {
        "Type": "LeastConnection"
    },
    "UpstreamHttpMethod": [ "Put", "Delete" ]
}
```

LoadBalancer将决定负载均衡的算法

>LeastConnection – 将请求发往最空闲的那个服务器
>
>RoundRobin – 轮流发送
>
>NoLoadBalance – 总是发往第一个请求或者是服务发现

**路由限流**

``` json
"RateLimitOptions": {
    "ClientWhitelist": [],
    "EnableRateLimiting": true,
    "Period": "5m",
    "PeriodTimespan": 1,
    "Limit": 1
}
```

- ClientWihteList 白名单

- EnableRateLimiting 是否启用限流

- Period 统计时间段：1s, 5m, 1h, 1d

- PeroidTimeSpan 多少秒之后客户端可以重试

- Limit 在统计时间段内允许的最大请求数量

  在 GlobalConfiguration下我们还可以进行以下配置

  ``` json
  "RateLimitOptions": {
    "DisableRateLimitHeaders": false,
    "QuotaExceededMessage": "Customize Tips!",
    "HttpStatusCode": 999,
    "ClientIdHeader" : "Test"
  }
  ```

  - Http头  X-Rate-Limit 和 Retry-After 是否禁用
  - QuotaExceedMessage 当请求过载被截断时返回的消息
  - HttpStatusCode 当请求过载被截断时返回的http status
  - ClientIdHeader 用来识别客户端的请求头，默认是 ClientId

  **熔断**

  ```json\
  "QoSOptions": {
      "ExceptionsAllowedBeforeBreaking":3,
      "DurationOfBreak":5,
      "TimeoutValue":5000
  }
  ```

  - ExceptionsAllowedBeforeBreaking 允许多少个异常请求
  - DurationOfBreak 熔断的时间，单位为秒
  - TimeoutValue 如果下游请求的处理时间超过多少则自动将请求设置为超

  **路由聚合**

  ```json
  {
      "ReRoutes": [
      {
      "DownstreamPathTemplate": "/",
      "UpstreamPathTemplate": "/laura",
      "UpstreamHttpMethod": [
     		 "Get"
      ],
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
          {
              "Host": "localhost",
              "Port": 51881
          }
      ],
      "Key": "Laura"
      },
      {
      "DownstreamPathTemplate": "/",
      "UpstreamPathTemplate": "/tom",
      "UpstreamHttpMethod": [
      "Get"
      ],
      "DownstreamScheme": "http",
      "DownstreamHostAndPorts": [
      {
      "Host": "localhost",
      "Port": 51882
      }
      ],
      "Key": "Tom"
      }
      ],
      "Aggregates": [
          {
          "ReRouteKeys": [
              "Tom",
              "Laura"
          ],
          "UpstreamPathTemplate": "/"
          }
      ]
  }
  ```

  当我们请求/的时候，会将/tom和/laura两个结果合并到一个response返回

  ``` json
  {"Tom":{"Age": 19},"Laura":{"Age": 25}}
  ```

  需要注意的是：

  - 聚合服务目前只支持返回json
  - 目前只支持Get方式请求下游服务
  - 任何下游的response header并会被丢弃
  - 如果下游服务返回404，聚合服务只是这个key的value为空，它不会返回404